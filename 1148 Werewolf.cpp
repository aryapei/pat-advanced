
/********************************************************************
#Input
	玩家人数N
	第一个玩家发言eq -2 表示第二个人是狼人
	第二个玩家发言eq +3 表示第三个人是好人
	...
	第N个玩家发言..

#Rule
	1. 两个狼人，有且只有一个狼人撒谎
	2. 总共有两个人撒谎，所以撒谎的人一个是狼人，一个是好人

#Output
	1. 有一个解，升序打印出两个狼人玩家的编号，以空格分开
	2. 有多个解，打印粗最小解，比如1 2 和1 3明显1 2 更小所以只打印出1 2即可
	3. 无解，打印No Solution
*******************************************************************/

#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

int main(){
	int n;
	cin >> n;
	// 声明类型为int，大小为n+1（我们只用了下标1-n）的动态数组，用来存放n个玩家的发言
	vector<int> v(n+1);
	for(int i=1;i<=n;i++) cin >> v[i];

	// 因为题目要求从小到大打印，所以这里从1到n遍历，保证多个解的条件下第一个找到的一定是最小解
	// 每轮开始，假设i j是狼人
	for(int i=1; i<=n; i++){
		for(int j=i+1; j<=n; j++){
			// a用来存储编号为i的玩家是好人1 还是狼人-1
			vector<int> a(n+1,1);   // 初始化全部是好人
			a[i] = a[j] = -1;		// i j赋值为狼人
			// lie动态数组用于存放撒谎的玩家的编号
			vector<int> lie;
			for(int k=1; k<=n; k++){
				// v[k]表示k号玩家的发言
				// x = abs(v[k])表示k号玩家的发言是针对x号玩家
				// a[x]表示x号玩家是好人1 还是狼人-1

				// 如果k号玩家说x号玩家是好人v[k]>0，但当前假设下x是狼人a[x]=-1；
				// 或者k号玩家说x号。    狼人v[k]<0,              好人a[x]=1，则k撒谎了
				// 即撒谎的判断条件是 v[k] * a[x] < 0
				if(v[k] * a[abs(v[k])] < 0)
					lie.push_back(k);
			}

			// 如果当前有两个人撒谎，并且一个狼人一个好人，则满足所有题目条件，打印狼人编号i j
			if(lie.size()==2 && a[lie[0]] + a[lie[1]] == 0){
				cout << i << " " << j;
				return 0;
			}
		}
	}
	cout << "No Solution";
	return 0;
}
